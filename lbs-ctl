#!/usr/bin/python
# SPDX-License-Identifier: GPL-2.0-only
# Copyright (c) 2023 Samsung Electronics Co., Ltd. All Rights Reserved.
#
# Author:
# Daniel Gomez <da.gomez@samsung.com>

from __future__ import print_function
from bcc import BPF
from bcc.utils import printb
from time import sleep
import argparse
import logging
import sys
import os
import subprocess
import json

try:
    import colorlog
    HAVE_COLORLOG = True
except ImportError:
    HAVE_COLORLOG = False
    pass

__version__ = "0.1"

b = BPF(text="""
""")


def blk_mq_prog(args: argparse.Namespace) -> str:
    """
    blk-mq probes:

    - blk_execute_rq_nowait:

    hardware:*blk_execute_rq_nowait:
    kfunc:blk_execute_rq_nowait
        struct request * rq
        bool at_head
    kprobe:blk_execute_rq_nowait
    software:*blk_execute_rq_nowait:

    - nvme_setup_cmd:

    hardware:*nvme_setup_cmd*:
    kfunc:__traceiter_nvme_setup_cmd
        void * __data
        struct request * req
        struct nvme_command * cmd
        int retval
    kfunc:nvme_setup_cmd
        struct nvme_ns * ns
        struct request * req
        blk_status_t retval
    kprobe:__traceiter_nvme_setup_cmd
    kprobe:nvme_setup_cmd
    software:*nvme_setup_cmd*:
    tracepoint:nvme:nvme_setup_cmd
        char disk[32]
        int ctrl_id
        int qid
        u8 opcode
        u8 flags
        u8 fctype
        u16 cid
        u32 nsid
        bool metadata
        u8 cdw10[24]
    """

    fc = {
        "kprobe__blk_execute_rq_nowait": "void kprobe__blk_execute_rq_nowait(struct pt_regs *ctx, struct request *req)",
        "kprobe__nvme_setup_cmd": "void kprobe__nvme_setup_cmd(struct pt_regs *ctx, struct nvme_ns *ns, struct request *req)"
        }
    probe = fc[args.probes]

    prog = """
    #include <uapi/linux/ptrace.h>
    #include <linux/blk-mq.h>
    #include <linux/bio.h>

    struct blk_mq_data_t {{
        char comm[TASK_COMM_LEN];
        /* struct bvec_iter */
        u32 bi_size;
        /* struct bio */
        u16 bi_vcnt;
        /* bio.h */
        u16 bio_max_vecs;
        /* struct request */
        u16 nr_phys_segments;
        u32 __data_len;
    }};

    BPF_PERF_OUTPUT(blk_mq_events);
    BPF_HISTOGRAM(bv_len, u16, 64);
    BPF_HASH(bv_len_last, u16, u16, 10240);

    {kprobe}
    {{
            struct blk_mq_data_t blk_mq_data = {{}};
            u16 i, aux;

            bpf_get_current_comm(&blk_mq_data.comm, sizeof(blk_mq_data.comm));
            blk_mq_data.bi_size = req->bio->bi_iter.bi_size;
            blk_mq_data.bi_vcnt = req->bio->bi_vcnt;
            blk_mq_data.bio_max_vecs = BIO_MAX_VECS;
            blk_mq_data.nr_phys_segments = req->nr_phys_segments;
            blk_mq_data.__data_len = req->__data_len;

            blk_mq_events.perf_submit(ctx, &blk_mq_data, sizeof(blk_mq_data));

            for (i=0; i<BIO_MAX_VECS; i++) {{
                    u16 idx=i; /* Avoid infinit loop detection in BCC */
                    if (i >= req->bio->bi_vcnt)
                            break;
                    aux = req->bio->bi_io_vec[i].bv_len;
                    if (aux == 0)
                            break;
                    bv_len.increment(bpf_log2l(aux));
                    bv_len_last.lookup_or_try_init(&idx, &aux);
            }}
    }}

    //BPF_PERF_OUTPUT(nvme_events);
    //BPF_HISTOGRAM(allocs, u16, 64);

    //struct nvme_data_t {{
    //    char comm[TASK_COMM_LEN];
    //    /* struct bvec_iter */
    //    u32 nr_allocations;
    //}};

    //TRACEPOINT_PROBE(nvme, nvme_pci_setup_prps_nprps) {{
    //        struct nvme_data_t nvme_data = {{}};

    //        nvme_data.nr_allocations = args->nr_allocations;
    //        allocs.increment(bpf_log2l(args->nr_allocations));

    //        bpf_get_current_comm(&nvme_data.comm, sizeof(nvme_data.comm));

    //        nvme_events.perf_submit(args, &nvme_data, sizeof(nvme_data));
    //        return 0;
    //}}
    """.format(kprobe=probe)
    logging.debug(prog)
    return prog


def _logger_conf(args: argparse.Namespace) -> None:
    """Setup the logging environment."""
    log = logging.getLogger()
    log.setLevel(logging.INFO)
    format_str = "%(asctime)s - %(levelname)-8s - %(message)s"
    date_format = "%Y-%m-%d %H:%M:%S"
    formatter = logging.Formatter(format_str, date_format)
    if os.isatty(2):
        cformat = "%(log_color)s" + format_str
        colors = {
            "DEBUG": "reset",
            "INFO": "bold_black",
            "WARNING": "bold_yellow",
            "ERROR": "bold_red",
            "CRITICAL": "bold_red",
        }
        if HAVE_COLORLOG:
            formatter = colorlog.ColoredFormatter(cformat, date_format, log_colors=colors)
        else:
            formatter = logging.Formatter(format_str, date_format)

    stream_handler = logging.StreamHandler()
    stream_handler.setFormatter(formatter)
    stream_handler = logging.StreamHandler()
    stream_handler.setFormatter(formatter)
    log.addHandler(stream_handler)
    log.setLevel(logging.INFO)
    _logger_level(args)
    return


def _logger_level(args: argparse.Namespace) -> None:
    if args.debug:
        logging.getLogger().setLevel(logging.DEBUG)
    return


def _parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="Large LBA Block Size Analysis tool")
    parser.add_argument(
        "-d",
        "--debug",
        help="enable debug output",
        action="store_true",
    )
    parser.add_argument(
        "-v",
        "--version",
        help="%(prog)s version",
        action="version",
        version=f"%(prog)s {__version__}",
    )
    subparser = parser.add_subparsers(help='sub command help', dest='cmd')
    blk = subparser.add_parser("blk-mq", help="'struct request' (blk-mq) tracer")
    blk.add_argument("probes", choices=["kprobe__blk_execute_rq_nowait", "kprobe__nvme_setup_cmd"])
    return parser

def _popen(
    cmd: list[str], environ: dict[str, str] = {}, comm: bool = True
) -> subprocess.Popen[bytes]:
    try:
        logging.debug(f"{' '.join(cmd)}")
        p = subprocess.Popen(
            cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=environ
        )
        if comm:
            stdout, stderr = p.communicate()
            if stdout:
                logging.debug(stdout.decode("utf-8"))
            if stderr:
                logging.debug(stderr.decode("utf-8"))
            logging.debug(f"Return code: {p.returncode}")
        return p
    except subprocess.CalledProcessError as exc:
        sys.exit(exc.returncode)


def update_data(prev, new):
    for p in prev.items():
        _key = p[0]; _old = p[1]; _new = new[_key]
        if (_old != _new):
            prev[_key] = _new
            logging.info("{key}: {old} -> {new}".format(key=_key, old=_old, new=_new))

def update_data_nvme(prev, new):
    for p in prev.items():
        _key = p[0]; _old = p[1]; _new = new[_key]
        if (_old != _new):
            prev[_key] = _new
            logging.warning("NVMe event!!!")
            logging.info("{key}: {old} -> {new}".format(key=_key, old=_old, new=_new))

data_d = {
    "nr_phys_segments": 0,
    "__data_len": 0,
    "bio_max_vecs": 0,
    "bi_size": 0,
    "bi_vcnt": 0,
    }
def print_bio_event(cpu, bio_data, size):
    global data_d
    bio_event = b["blk_mq_events"].event(bio_data)

    comm = bio_event.comm.decode("utf8")
    if (comm != "fio"):
        return

    data_current_d = {
        "nr_phys_segments": bio_event.nr_phys_segments,
        "__data_len": bio_event.__data_len,
        "bio_max_vecs": bio_event.bio_max_vecs,
        "bi_size": bio_event.bi_size,
        "bi_vcnt": bio_event.bi_vcnt,
        }
    update_data(data_d, data_current_d)

nvme_data_d = {
    "nr_allocations": 99,
    }
def print_nvme_event(cpu, nvme_data, size):
    nvme_event = b["nvme_events"].event(nvme_data)

    comm = nvme_event.comm.decode("utf8")
    if (comm != "fio"):
        return

    nvme_data_current_d = {
        "nr_allocations": nvme_event.nr_allocations,
        }
    update_data_nvme(nvme_data_d, nvme_data_current_d)

def blk_mq_trace(args: argparse.Namespace) -> None:
    global b
    prog = blk_mq_prog(args)
    logging.info("Loading blk-mq. Please, wait to launch the test...")
    test_ex = "fio -iodepth=1 -rw=read -ioengine=io_uring_cmd -bs=64k -numjobs=1 -size=1G -filename=/dev/ng0n1 -name=io_uring_1 -loop=4"
    logging.info("Execute the following test in other terminal:\n{test}".format(test=test_ex))
    b = BPF(text=prog)
    logging.info("Tracing enabled. Press 'Ctrl+C' to cancel.")
    b["blk_mq_events"].open_perf_buffer(print_bio_event)
    #b["nvme_events"].open_perf_buffer(print_nvme_event)
    try:
        while 1:
            b.perf_buffer_poll()
            sleep(0.1)
    except KeyboardInterrupt:
        print()

    bv_len = b["bv_len"]
    logging.info("log2 'bv_len' histogram")
    bv_len.print_log2_hist("bv_len")
    bv_len_last = b["bv_len_last"]

    allocs = b["allocs"]
    logging.info("log2 'allocs' histogram")
    allocs.print_log2_hist("allocs")

    logging.info("Last 'bv_len'")
    for k, v in sorted(bv_len_last.items(), key=lambda bv_len: bv_len[1].value):
        logging.info("key: {}, value: {}".format(k.value, v.value))

    logging.debug("blk-mq completed")


def print_system_info():
    # PAGE_SIZE
    aux = _popen(["/usr/bin/getconf", "PAGE_SIZE"], comm=True)
    page_size = aux.communicate()[0].decode("utf-8").replace("\n", "")
    logging.info("PAGE_SIZE={page_size}".format(page_size=page_size))

    # NVMe blk device
    dev = ["nvme0n1"]
    sysfs = ["hw_sector_size", "logical_block_size", "max_discard_segments", "max_hw_sectors_kb", "max_integrity_segments",
             "max_sectors_kb", "max_integrity_segments", "max_sectors_kb", "max_segment_size", "max_segments", "minimum_io_size",
             "nomerges", "nr_requests", "optimal_io_size", "physical_block_size", "scheduler"]
    for d in dev:
        for s in sysfs:
            with open("/sys/class/block/{device}/queue/{sysfs}".format(device=d, sysfs=s), "r") as f:
                logging.info("{device}: {sysfs}: {val}".format(device=d, sysfs=s, val=f.read().replace("\n", "")))

    # NVMe mdts
    dev = ["nvme0"]
    for d in dev:
        aux = _popen(["/usr/sbin/nvme", "id-ctrl", "/dev/{dev}".format(dev=d), "--output-format=json"])
        mdts = json.loads(aux.communicate()[0].decode("utf-8"))["mdts"]
        logging.info("{dev}: mdts: {mdts}".format(dev=d, mdts=mdts))


def main() -> None:
    """The tool."""
    p = _parser()
    args, _ = p.parse_known_args()

    _logger_conf(args)

    logging.info("Large Block Size Analysis tool")

    if not args.cmd:
        p.print_usage()
        return

    # System & dev info
    print_system_info()

    disp = { "blk-mq": blk_mq_trace }
    disp[args.cmd](args)


if __name__ == "__main__":
    ret = 0
    try:
        main()
    except Exception:
        ret = 1
        import traceback

        traceback.print_exc()
    sys.exit(ret)
