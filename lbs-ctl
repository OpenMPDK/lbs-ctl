#!/usr/bin/python
# SPDX-License-Identifier: GPL-2.0-only
# Copyright (c) 2023 Samsung Electronics Co., Ltd. All Rights Reserved.
#
# Author:
# Daniel Gomez <da.gomez@samsung.com>

from __future__ import print_function
from bcc import BPF
from bcc.utils import printb
from time import sleep
import argparse
import logging
import sys
import os

try:
    import colorlog
    HAVE_COLORLOG = True
except ImportError:
    HAVE_COLORLOG = False
    pass

__version__ = "0.1"

b = BPF(text="""
""")


def blk_mq_prog():
    """
    kprobe__blk_execute_rq_nowait
    """

    prog = """
    #include <uapi/linux/ptrace.h>
    #include <linux/blk-mq.h>
    #include <linux/bio.h>

    struct blk_mq_data_t {
        char comm[TASK_COMM_LEN];
        /* struct bvec_iter */
        u32 bi_size;
        /* struct bio */
        u16 bi_vcnt;
        /* bio.h */
        u16 bio_max_vecs;
        /* struct request */
        u16 nr_phys_segments;
        u32 __data_len;
    };

    BPF_PERF_OUTPUT(blk_mq_events);
    BPF_HISTOGRAM(bv_len, u16, 64);
    BPF_HASH(bv_len_last, u16, u16, 10240);

    void kprobe__blk_execute_rq_nowait(struct pt_regs *ctx, struct request *req)
    {
            struct blk_mq_data_t blk_mq_data = {};
            u16 i, aux;

            bpf_get_current_comm(&blk_mq_data.comm, sizeof(blk_mq_data.comm));
            blk_mq_data.bi_size = req->bio->bi_iter.bi_size;
            blk_mq_data.bi_vcnt = req->bio->bi_vcnt;
            blk_mq_data.bio_max_vecs = BIO_MAX_VECS;
            blk_mq_data.nr_phys_segments = req->nr_phys_segments;
            blk_mq_data.__data_len = req->__data_len;

            blk_mq_events.perf_submit(ctx, &blk_mq_data, sizeof(blk_mq_data));

            for (i=0; i<BIO_MAX_VECS; i++) {
                    u16 idx=i; /* Avoid infinit loop detection in BCC */
                    if (i >= req->bio->bi_vcnt)
                            break;
                    aux = req->bio->bi_io_vec[i].bv_len;
                    if (aux == 0)
                            break;
                    bv_len.increment(bpf_log2l(aux));
                    bv_len_last.lookup_or_try_init(&idx, &aux);
            }
    }
    """
    logging.debug(prog)
    return prog


def _logger_conf(args: argparse.Namespace) -> None:
    """Setup the logging environment."""
    log = logging.getLogger()
    log.setLevel(logging.INFO)
    format_str = "%(asctime)s - %(levelname)-8s - %(message)s"
    date_format = "%Y-%m-%d %H:%M:%S"
    formatter = logging.Formatter(format_str, date_format)
    if os.isatty(2):
        cformat = "%(log_color)s" + format_str
        colors = {
            "DEBUG": "reset",
            "INFO": "bold_black",
            "WARNING": "bold_yellow",
            "ERROR": "bold_red",
            "CRITICAL": "bold_red",
        }
        if HAVE_COLORLOG:
            formatter = colorlog.ColoredFormatter(cformat, date_format, log_colors=colors)
        else:
            formatter = logging.Formatter(format_str, date_format)

    stream_handler = logging.StreamHandler()
    stream_handler.setFormatter(formatter)
    stream_handler = logging.StreamHandler()
    stream_handler.setFormatter(formatter)
    log.addHandler(stream_handler)
    log.setLevel(logging.INFO)
    _logger_level(args)
    return


def _logger_level(args: argparse.Namespace) -> None:
    if args.debug:
        logging.getLogger().setLevel(logging.DEBUG)
    return


def _parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="Large LBA Block Size Analysis tool")
    parser.add_argument(
        "-d",
        "--debug",
        help="enable debug output",
        action="store_true",
    )
    parser.add_argument(
        "-v",
        "--version",
        help="%(prog)s version",
        action="version",
        version=f"%(prog)s {__version__}",
    )
    subparser = parser.add_subparsers(help='sub command help', dest='cmd')
    subparser.add_parser("blk-mq", help="blk-mq tracer")
    return parser


def print_watch(prev, new, name):
    if (prev != new):
        logging.info("{name}={new}".format(name=name, new=new))
    return new

nr_phys_segments = __data_len = 0
bio_max_vecs = bi_size = bi_vcnt = 0
bi_size_kb = __data_len_kb = 0
phys_segment_len = 0
def print_bio_event(cpu, bio_data, size):
    global nr_phys_segments, __data_len
    global bio_max_vecs, bi_size, bi_vcnt
    global bi_size_kb, __data_len_kb
    global phys_segment_len
    bio_event = b["blk_mq_events"].event(bio_data)

    comm = bio_event.comm.decode("utf8")
    if (comm != "fio"):
        return

    __data_len = print_watch(__data_len, bio_event.__data_len, "__data_len")
    __data_len_kb = print_watch(__data_len_kb, int(bio_event.__data_len/1024), "__data_len_kb")
    nr_phys_segments = print_watch(nr_phys_segments, bio_event.nr_phys_segments, "nr_phys_segments")
    phys_segment_len = print_watch(phys_segment_len, int(bio_event.__data_len/bio_event.nr_phys_segments), "phys_segment_len")
    bio_max_vecs = print_watch(bio_max_vecs, bio_event.bio_max_vecs, "BIO_MAX_VECS")
    bi_size = print_watch(bi_size, bio_event.bi_size, "bi_size")
    bi_size_kb = print_watch(bi_size_kb, int(bio_event.bi_size/1024), "bi_size_kb")
    bi_vcnt = print_watch(bi_vcnt, bio_event.bi_vcnt, "bi_vcnt")


def blk_mq_trace():
    global b
    prog = blk_mq_prog()
    logging.info("Loading blk-mq. Please, wait to launch the test...")
    test_ex = "fio -iodepth=1 -rw=read -ioengine=io_uring_cmd -bs=64k -numjobs=1 -size=1G -filename=/dev/ng0n1 -name=io_uring_1 -loop=4"
    logging.info("Execute the following test in other terminal:\n{test}".format(test=test_ex))
    b = BPF(text=prog)
    logging.info("Tracing enabled. Press 'Ctrl+C' to cancel.")
    b["blk_mq_events"].open_perf_buffer(print_bio_event)
    try:
        while 1:
            b.perf_buffer_poll()
            sleep(0.1)
    except KeyboardInterrupt:
        print()

    bv_len = b["bv_len"]
    logging.info("log2 'bv_len' histogram")
    bv_len.print_log2_hist("bv_len")
    bv_len_last = b["bv_len_last"]

    logging.info("Last 'bv_len'")
    for k, v in sorted(bv_len_last.items(), key=lambda bv_len: bv_len[1].value):
        logging.info("key: {}, value: {}".format(k.value, v.value))

    logging.debug("blk-mq completed")


def main() -> None:
    """The tool."""
    p = _parser()
    args, _ = p.parse_known_args()

    _logger_conf(args)

    logging.info("Large Block Size Analysis tool")

    if not args.cmd:
        p.print_usage()
        return

    disp = { "blk-mq": blk_mq_trace }
    disp[args.cmd]()


if __name__ == "__main__":
    ret = 0
    try:
        main()
    except Exception:
        ret = 1
        import traceback

        traceback.print_exc()
    sys.exit(ret)
